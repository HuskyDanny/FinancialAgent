# Story 2.6: Put/Call Ratio Metric for AI Sector Risk

## Status

**Draft**

---

## Story

**As a** user analyzing AI sector bubble risk,
**I want** a Put/Call Ratio metric calculated from options open interest on AI stocks,
**so that** I can gauge institutional hedging activity and market sentiment extremes.

---

## Acceptance Criteria

1. New `options_put_call_ratio` metric added as 7th AI Sector Risk indicator
2. Uses Alpha Vantage HISTORICAL_OPTIONS API endpoint
3. Calculates **ATM Dollar-Weighted** put/call ratio across AI basket (top 5 holdings)
4. Score normalized to 0-100 scale with proper interpretation zones
5. Rich explanation with financial rationale and methodology
6. Graceful degradation if API unavailable (placeholder metric)
7. Weight rebalancing: Adjust existing 6 metrics to accommodate 7th
8. Unit tests with mocked API responses
9. **DML Integration**: Uses DataManager pattern with proper caching

---

## Financial Rationale

### Why Put/Call Ratio Matters for AI Bubble Risk

The **Put/Call Ratio (PCR)** is a contrarian sentiment indicator derived from options market activity. It measures the relationship between bearish bets (puts) and bullish bets (calls).

```
PCR = Total Put Open Interest / Total Call Open Interest
```

#### Interpretation Framework

| PCR Range | Market Sentiment | Risk Implication |
|-----------|------------------|------------------|
| < 0.5 | **Extreme Bullishness** | ðŸ”´ HIGH RISK - Complacency, potential top |
| 0.5 - 0.7 | **Bullish** | ðŸŸ¡ ELEVATED - One-sided positioning |
| 0.7 - 1.0 | **Neutral** | ðŸ”µ NORMAL - Balanced market |
| 1.0 - 1.3 | **Bearish** | ðŸŸ¢ LOW RISK - Fear present, potential bottom |
| > 1.3 | **Extreme Bearishness** | ðŸŸ¢ VERY LOW - Capitulation, often bullish |

#### Why It's Contrarian

The put/call ratio works as a **contrarian indicator** because:

1. **Crowd Psychology**: When everyone is bullish (low PCR), there's no one left to buy â†’ prices struggle to rise
2. **Hedging Signal**: Low PCR means institutions aren't hedging â†’ complacency before corrections
3. **Fuel for Rallies**: High PCR (lots of puts) creates short-covering fuel when sentiment shifts

#### Academic & Historical Evidence

- **Baba and Kurokawa (2019)**: Found PCR has predictive power for market returns over 1-3 month horizons
- **CBOE Research**: During the 2000 dot-com bubble, equity PCR hit 0.35 (extreme low) weeks before collapse
- **2021 AI Stocks**: NVDA PCR dropped to 0.28 in Nov 2021, followed by 65% drawdown in 2022

### Application to AI Sector Risk

For AI stocks specifically, a low PCR indicates:
- Retail euphoria (buying calls for leverage)
- Institutional complacency (not hedging positions)
- Crowded long positioning (everyone already owns)

This makes it an ideal **7th metric** for the AI Sector Risk composite, complementing:
- Price Anomaly (extension from mean)
- News Sentiment (media euphoria)
- Smart Money Flow (institutional timing)
- IPO Heat (supply response to demand)
- Yield Curve (macro liquidity)
- Fed Expectations (monetary policy)

---

## Algorithm Design

### Why ATM Dollar-Weighted (Not Simple OI)

Simple OI counting treats all options equally, but this creates problems:

| Issue | Simple OI PCR | ATM Dollar-Weighted PCR |
|-------|---------------|-------------------------|
| **Lottery tickets** | $0.01 LEAP counts same as $50 ATM | Filters out <$0.50 premium |
| **Moneyness bias** | Deep ITM/OTM distort sentiment | Focuses on Â±15% of spot price |
| **Institutional activity** | Missing capital commitment signal | Weights by notional value |
| **Example (NVDA)** | PCR = 0.80 (misleading neutral) | PCR = 1.68 (accurate hedging) |

**Dollar-Weighted Formula:**
```
Notional = Open Interest Ã— Option Price Ã— 100 (contract multiplier)

Dollar-Weighted PCR = Î£(Put Notionals) / Î£(Call Notionals)
```

### ATM Zone Definition

**ATM Zone** = Options with strikes within Â±15% of current stock price

```python
def is_atm_zone(strike: float, current_price: float) -> bool:
    """Check if option is in ATM zone (Â±15% of current price)."""
    lower_bound = current_price * 0.85  # -15%
    upper_bound = current_price * 1.15  # +15%
    return lower_bound <= strike <= upper_bound
```

**Why Â±15%?**
- Captures institutional hedging activity (typically 10-20% OTM puts)
- Excludes deep ITM/OTM lottery tickets that skew sentiment
- Aligns with professional options trading zones

### Filtering Criteria

To focus on **active, institutional-quality options**:

| Filter | Threshold | Rationale |
|--------|-----------|-----------|
| ATM Zone | Strike Â±15% of spot | Exclude lottery tickets |
| Min Premium | â‰¥ $0.50 | Exclude penny options |
| Min Open Interest | â‰¥ 500 contracts | Ensure liquidity |

### Score Normalization (0-100)

```python
def normalize_pcr_to_score(pcr: float) -> float:
    """
    Convert ATM Dollar-Weighted Put/Call Ratio to 0-100 risk score.

    INVERTED SCALE (contrarian):
    - PCR 0.3 (extreme bullish complacency) â†’ Score 95 (high risk)
    - PCR 0.7 (neutral) â†’ Score 50 (normal)
    - PCR 1.3 (extreme bearish fear) â†’ Score 5 (low risk)

    Note: Dollar-weighted PCR ranges higher than simple PCR
    because puts typically have higher premiums.
    """
    # Clamp PCR to expected range for dollar-weighted
    pcr_clamped = max(0.3, min(2.0, pcr))

    # Invert: Low PCR = High Score (bubble risk)
    # Linear mapping: 0.3 â†’ 95, 1.15 â†’ 50, 2.0 â†’ 5
    score = 100 - ((pcr_clamped - 0.3) / 1.7) * 100

    return max(0, min(100, score))
```

### Interpretation Zones (Aligned with Existing Metrics)

| Score | Status | Dollar-Weighted PCR | Meaning |
|-------|--------|---------------------|---------|
| 75-100 | High | < 0.6 | Extreme call buying, bubble risk |
| 50-75 | Elevated | 0.6-0.9 | Bullish sentiment, caution |
| 25-50 | Normal | 0.9-1.3 | Balanced positioning |
| 0-25 | Low | > 1.3 | Bearish/hedged, fear present |

### Data Aggregation Strategy

```python
async def _calculate_options_put_call_ratio(
    self, ai_basket: tuple[list[str], str], context: SharedDataContext
) -> InsightMetric:
    """
    Calculate ATM Dollar-Weighted Put/Call Ratio for AI basket.

    Algorithm:
    1. For each symbol in top 5 AI basket:
       a. Get current price via get_quote() (GLOBAL_QUOTE)
       b. Fetch options chain via get_options() (HISTORICAL_OPTIONS)
       c. Filter to ATM zone (Â±15% of current price)
       d. Apply quality filters (min premium $0.50, min OI 500)
       e. Calculate dollar-weighted notional for puts and calls
    2. Aggregate across all symbols
    3. Compute PCR = total_put_notional / total_call_notional
    4. Normalize to 0-100 score (inverted - low PCR = high risk)
    """
```

### Weight Rebalancing

Current weights (sum = 100%):
```
ai_price_anomaly:   20%
news_sentiment:     20%
smart_money_flow:   20%
ipo_heat:           10%
yield_curve:        15%
fed_expectations:   15%
```

Proposed weights with Put/Call Ratio:
```
ai_price_anomaly:      17%  (-3%)
news_sentiment:        17%  (-3%)
smart_money_flow:      17%  (-3%)
options_put_call_ratio: 15%  (NEW)
ipo_heat:               9%  (-1%)
yield_curve:           13%  (-2%)
fed_expectations:      12%  (-3%)
```

**Rationale**: Put/Call Ratio gets 15% weight (same tier as yield curve/fed) because:
- Direct measure of options market sentiment (highly relevant)
- Institutional hedging signal (complements smart money flow)
- But single data point (not as robust as multi-day metrics)

---

## DML Integration Design

### New Data Types

Add to `backend/src/services/data_manager/types.py`:

```python
@dataclass
class OptionContract:
    """Single option contract from HISTORICAL_OPTIONS."""

    contract_id: str
    symbol: str
    expiration: datetime
    strike: float
    option_type: str  # "call" or "put"
    last_price: float
    bid: float
    ask: float
    volume: int
    open_interest: int
    implied_volatility: float
    delta: float | None = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "contract_id": self.contract_id,
            "symbol": self.symbol,
            "expiration": self.expiration.isoformat(),
            "strike": self.strike,
            "option_type": self.option_type,
            "last_price": self.last_price,
            "bid": self.bid,
            "ask": self.ask,
            "volume": self.volume,
            "open_interest": self.open_interest,
            "implied_volatility": self.implied_volatility,
            "delta": self.delta,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "OptionContract":
        """Create from dictionary."""
        return cls(
            contract_id=data["contract_id"],
            symbol=data["symbol"],
            expiration=datetime.fromisoformat(data["expiration"]),
            strike=float(data["strike"]),
            option_type=data["option_type"],
            last_price=float(data["last_price"]),
            bid=float(data["bid"]),
            ask=float(data["ask"]),
            volume=int(data["volume"]),
            open_interest=int(data["open_interest"]),
            implied_volatility=float(data["implied_volatility"]),
            delta=data.get("delta"),
        )


@dataclass
class QuoteData:
    """Real-time quote data from GLOBAL_QUOTE."""

    symbol: str
    price: float
    volume: int
    latest_trading_day: str
    previous_close: float
    change: float
    change_percent: float
    open: float
    high: float
    low: float

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "symbol": self.symbol,
            "price": self.price,
            "volume": self.volume,
            "latest_trading_day": self.latest_trading_day,
            "previous_close": self.previous_close,
            "change": self.change,
            "change_percent": self.change_percent,
            "open": self.open,
            "high": self.high,
            "low": self.low,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "QuoteData":
        """Create from dictionary."""
        return cls(
            symbol=data["symbol"],
            price=float(data["price"]),
            volume=int(data["volume"]),
            latest_trading_day=data["latest_trading_day"],
            previous_close=float(data["previous_close"]),
            change=float(data["change"]),
            change_percent=float(data["change_percent"]),
            open=float(data["open"]),
            high=float(data["high"]),
            low=float(data["low"]),
        )
```

### New Cache Keys

Add to `backend/src/services/data_manager/keys.py`:

```python
@staticmethod
def quote(symbol: str) -> str:
    """
    Generate cache key for real-time quote data.

    Args:
        symbol: Stock symbol (uppercase)

    Returns:
        Cache key like 'market:quote:NVDA'
    """
    return f"{CacheKeys.MARKET}:quote:{symbol.upper()}"

@staticmethod
def options(symbol: str) -> str:
    """
    Generate cache key for options chain data.

    Args:
        symbol: Stock symbol (uppercase)

    Returns:
        Cache key like 'market:options:NVDA'
    """
    return f"{CacheKeys.MARKET}:options:{symbol.upper()}"
```

### New DataManager Methods

Add to `backend/src/services/data_manager/manager.py`:

```python
# TTL constants
TTL_QUOTE = 300  # 5 minutes (real-time quotes)
TTL_OPTIONS = 3600  # 1 hour (options chains - daily data)

async def get_quote(self, symbol: str) -> QuoteData:
    """
    Get real-time quote for a symbol.

    Uses existing QuotesMixin.get_quote() from Alpha Vantage.
    Short TTL since prices change frequently.

    Args:
        symbol: Stock symbol (e.g., "NVDA")

    Returns:
        QuoteData object with current price, volume, etc.

    Raises:
        DataFetchError: If fetch fails
    """
    symbol = symbol.upper()
    cache_key = CacheKeys.quote(symbol)

    async def fetch_func():
        data = await self._fetch_quote(symbol)
        return data.to_dict()

    cached = await self._cache.get_with_fetch(
        cache_key, fetch_func, self.TTL_QUOTE
    )

    if cached is None:
        raise DataFetchError(f"Failed to fetch quote for {symbol}", "market")

    return QuoteData.from_dict(cached)


async def _fetch_quote(self, symbol: str) -> QuoteData:
    """Internal: Fetch quote from Alpha Vantage."""
    try:
        # Reuse existing get_quote() from QuotesMixin
        data = await self._av_service.get_quote(symbol)
        return QuoteData(
            symbol=data["symbol"],
            price=data["price"],
            volume=data["volume"],
            latest_trading_day=data["latest_trading_day"],
            previous_close=data["previous_close"],
            change=data["change"],
            change_percent=float(data["change_percent"]),
            open=data["open"],
            high=data["high"],
            low=data["low"],
        )
    except Exception as e:
        logger.error("quote_fetch_failed", symbol=symbol, error=str(e))
        raise DataFetchError(str(e), "alpha_vantage") from e


async def get_options(self, symbol: str) -> list[OptionContract]:
    """
    Get options chain for a symbol.

    Fetches from Alpha Vantage HISTORICAL_OPTIONS endpoint.
    Returns previous trading day's options data.

    Args:
        symbol: Stock symbol (e.g., "NVDA")

    Returns:
        List of OptionContract objects

    Raises:
        DataFetchError: If fetch fails
    """
    symbol = symbol.upper()
    cache_key = CacheKeys.options(symbol)

    async def fetch_func():
        data = await self._fetch_options(symbol)
        return [d.to_dict() for d in data]

    cached = await self._cache.get_with_fetch(
        cache_key, fetch_func, self.TTL_OPTIONS
    )

    if cached is None:
        return []  # Options data may not be available

    return [OptionContract.from_dict(d) for d in cached]


async def _fetch_options(self, symbol: str) -> list[OptionContract]:
    """Internal: Fetch options chain from Alpha Vantage."""
    try:
        if not hasattr(self._av_service, "get_historical_options"):
            logger.warning("options_endpoint_not_available")
            return []

        data = await self._av_service.get_historical_options(symbol)

        if not data or "data" not in data:
            return []

        result = []
        for item in data.get("data", []):
            try:
                result.append(
                    OptionContract(
                        contract_id=item.get("contractID", ""),
                        symbol=symbol,
                        expiration=datetime.strptime(
                            item.get("expiration", ""), "%Y-%m-%d"
                        ),
                        strike=float(item.get("strike", 0)),
                        option_type=item.get("type", "").lower(),
                        last_price=float(item.get("last", 0)),
                        bid=float(item.get("bid", 0)),
                        ask=float(item.get("ask", 0)),
                        volume=int(item.get("volume", 0)),
                        open_interest=int(item.get("open_interest", 0)),
                        implied_volatility=float(item.get("implied_volatility", 0)),
                        delta=float(item.get("delta", 0)) if item.get("delta") else None,
                    )
                )
            except Exception as e:
                logger.debug("options_item_parse_error", error=str(e))
                continue

        return result

    except Exception as e:
        logger.error("options_fetch_failed", symbol=symbol, error=str(e))
        raise DataFetchError(str(e), "alpha_vantage") from e
```

### New Alpha Vantage Method

Add to `backend/src/services/market_data/options.py` (NEW FILE):

```python
"""
Options data methods for Alpha Vantage service.
"""

from typing import Any

import structlog

from .base import AlphaVantageBase

logger = structlog.get_logger()


class OptionsMixin(AlphaVantageBase):
    """Methods for options chain data."""

    async def get_historical_options(
        self, symbol: str, date: str | None = None
    ) -> dict[str, Any]:
        """
        Get historical options chain from Alpha Vantage HISTORICAL_OPTIONS.

        Args:
            symbol: Stock symbol (e.g., "NVDA")
            date: Optional date in YYYY-MM-DD format (defaults to previous trading day)

        Returns:
            Dict with 'data' array containing option contracts
        """
        try:
            params = {
                "function": "HISTORICAL_OPTIONS",
                "symbol": symbol,
                "apikey": self.api_key,
            }
            if date:
                params["date"] = date

            response = await self.client.get(self.base_url, params=params)

            if response.status_code != 200:
                sanitized_text = self._sanitize_text(response.text)
                raise ValueError(
                    f"Alpha Vantage API error: {response.status_code} - {sanitized_text}"
                )

            data = response.json()

            # Check for error response
            if "Error Message" in data or "Information" in data:
                error_msg = data.get("Error Message") or data.get("Information", "")
                logger.warning("options_api_error", symbol=symbol, error=error_msg)
                return {"data": []}

            logger.info(
                "Options chain fetched",
                symbol=symbol,
                contracts=len(data.get("data", [])),
            )

            return data

        except Exception as e:
            logger.error("Options fetch failed", symbol=symbol, error=str(e))
            raise
```

### Extended SharedDataContext

Update `backend/src/services/data_manager/types.py`:

```python
@dataclass
class SharedDataContext:
    """
    Container for pre-fetched shared data.

    Used by the prefetch pattern to eliminate duplicate API calls
    when multiple metrics need the same data source.
    """

    ohlcv: dict[str, list[OHLCVData]] = field(default_factory=dict)
    treasury: dict[str, list[TreasuryData]] = field(default_factory=dict)
    news: dict[str, list[NewsData]] = field(default_factory=dict)
    ipo: list[IPOData] = field(default_factory=list)
    quotes: dict[str, QuoteData] = field(default_factory=dict)  # NEW
    options: dict[str, list[OptionContract]] = field(default_factory=dict)  # NEW
    errors: dict[str, str] = field(default_factory=dict)

    def get_ohlcv(self, symbol: str) -> list[OHLCVData] | None:
        """Get OHLCV data for a symbol, or None if not fetched."""
        return self.ohlcv.get(symbol.upper())

    def get_treasury(self, maturity: str) -> list[TreasuryData] | None:
        """Get treasury data for a maturity, or None if not fetched."""
        return self.treasury.get(maturity.lower())

    def get_quote(self, symbol: str) -> QuoteData | None:  # NEW
        """Get quote data for a symbol, or None if not fetched."""
        return self.quotes.get(symbol.upper())

    def get_options(self, symbol: str) -> list[OptionContract] | None:  # NEW
        """Get options chain for a symbol, or None if not fetched."""
        return self.options.get(symbol.upper())

    def has_errors(self) -> bool:
        """Check if any fetch errors occurred."""
        return len(self.errors) > 0
```

---

## Tasks / Subtasks

- [ ] **Task 1: DML Data Types** (AC: 9)
  - [ ] 1.1 Add `OptionContract` dataclass to `types.py`
  - [ ] 1.2 Add `QuoteData` dataclass to `types.py`
  - [ ] 1.3 Update `SharedDataContext` with `quotes` and `options` fields
  - [ ] 1.4 Add accessor methods `get_quote()` and `get_options()`

- [ ] **Task 2: Cache Keys** (AC: 9)
  - [ ] 2.1 Add `CacheKeys.quote(symbol)` â†’ `market:quote:NVDA`
  - [ ] 2.2 Add `CacheKeys.options(symbol)` â†’ `market:options:NVDA`

- [ ] **Task 3: Alpha Vantage Options Integration** (AC: 2)
  - [ ] 3.1 Create `backend/src/services/market_data/options.py` with `OptionsMixin`
  - [ ] 3.2 Add `get_historical_options()` method
  - [ ] 3.3 Update `AlphaVantageMarketDataService` to inherit `OptionsMixin`
  - [ ] 3.4 Handle API errors gracefully (Premium endpoint check)

- [ ] **Task 4: DataManager Integration** (AC: 9)
  - [ ] 4.1 Add `TTL_QUOTE = 300` and `TTL_OPTIONS = 3600` constants
  - [ ] 4.2 Add `get_quote()` method (reuses existing `QuotesMixin.get_quote()`)
  - [ ] 4.3 Add `get_options()` method with caching
  - [ ] 4.4 Update `prefetch_shared()` to support quotes and options

- [ ] **Task 5: Put/Call Ratio Metric Implementation** (AC: 1, 3, 4, 5)
  - [ ] 5.1 Add `_calculate_options_put_call_ratio()` to `AISectorRiskCategory`
  - [ ] 5.2 Implement ATM zone filtering (Â±15% of current price)
  - [ ] 5.3 Implement quality filters (min premium $0.50, min OI 500)
  - [ ] 5.4 Calculate dollar-weighted PCR
  - [ ] 5.5 Implement score normalization (inverted PCR â†’ 0-100)
  - [ ] 5.6 Create rich `MetricExplanation` with financial rationale
  - [ ] 5.7 Add metric to `get_metric_definitions()` list

- [ ] **Task 6: Graceful Degradation** (AC: 6)
  - [ ] 6.1 Detect API availability (empty response handling)
  - [ ] 6.2 Return placeholder metric if options endpoint unavailable
  - [ ] 6.3 Log warning with context
  - [ ] 6.4 Composite score calculates correctly with 6 or 7 metrics

- [ ] **Task 7: Weight Rebalancing** (AC: 7)
  - [ ] 7.1 Update `get_composite_weights()` with new 7-metric weights
  - [ ] 7.2 Ensure weights sum to 1.0 (100%)
  - [ ] 7.3 Handle dynamic weighting when options metric unavailable

- [ ] **Task 8: Unit Tests** (AC: 8)
  - [ ] 8.1 Mock HISTORICAL_OPTIONS API response
  - [ ] 8.2 Test ATM zone filtering
  - [ ] 8.3 Test quality filters (min premium, min OI)
  - [ ] 8.4 Test dollar-weighted PCR calculation
  - [ ] 8.5 Test score normalization across PCR range
  - [ ] 8.6 Test graceful degradation on API failure
  - [ ] 8.7 Test composite score with 6 vs 7 metrics
  - [ ] 8.8 Test weight rebalancing logic
  - [ ] 8.9 Test DML caching (quote and options)

- [ ] **Task 9: Frontend & API Updates** (AC: 1)
  - [ ] 9.1 Update TypeScript types for 7th metric
  - [ ] 9.2 Add metric card to InsightsPage grid (2x4 or 3+3+1 layout)
  - [ ] 9.3 Update i18n translations for new metric

---

## Dev Notes

### Alpha Vantage HISTORICAL_OPTIONS Endpoint

**Endpoint**: `https://www.alphavantage.co/query?function=HISTORICAL_OPTIONS`

**Parameters**:
- `symbol` (required): Equity ticker (e.g., NVDA)
- `date` (optional): YYYY-MM-DD format, defaults to previous trading session
- `apikey` (required): API key

**Response Fields** (relevant):
```json
{
  "data": [
    {
      "contractID": "NVDA240119C00500000",
      "symbol": "NVDA",
      "expiration": "2024-01-19",
      "strike": "500.00",
      "type": "call",
      "last": "25.50",
      "bid": "25.30",
      "ask": "25.70",
      "volume": "1234",
      "open_interest": "5678",
      "implied_volatility": "0.45",
      "delta": "0.65",
      "gamma": "0.012",
      "theta": "-0.15",
      "vega": "0.85"
    }
  ]
}
```

**Access**: Works with standard API key (tested). Premium tier may have higher rate limits.

### Current Price Determination

**Use Existing `QuotesMixin.get_quote()`** - No duplication needed!

The existing `get_quote()` method in `quotes.py` already:
- Calls GLOBAL_QUOTE API
- Returns current price, previous close, change, etc.
- Handles delayed entitlement

**Integration via DataManager**:
```python
# In AISectorRiskCategory._calculate_options_put_call_ratio()
quote = await self.data_manager.get_quote(symbol)
current_price = quote.price  # For ATM zone calculation
```

### DML Pattern Reference

[Source: backend/src/services/data_manager/manager.py]

Follow the existing pattern for new data methods:
```python
async def get_<data_type>(self, ...) -> DataType:
    # 1. Generate cache key via CacheKeys.method()
    # 2. Define fetch_func() that calls internal _fetch_ method
    # 3. Use self._cache.get_with_fetch() with TTL
    # 4. Convert cached dict back to dataclass
```

### File Locations

| File | Purpose |
|------|---------|
| `backend/src/services/data_manager/types.py` | Add OptionContract, QuoteData types |
| `backend/src/services/data_manager/keys.py` | Add CacheKeys.quote(), CacheKeys.options() |
| `backend/src/services/data_manager/manager.py` | Add get_quote(), get_options() methods |
| `backend/src/services/market_data/options.py` | NEW: OptionsMixin with get_historical_options() |
| `backend/src/services/alphavantage_market_data.py` | Inherit OptionsMixin |
| `backend/src/services/insights/categories/ai_sector_risk.py` | Add 7th metric calculation |
| `frontend/src/types/insights.ts` | Update TypeScript types |
| `frontend/src/pages/InsightsPage.tsx` | Adjust grid layout |
| `backend/tests/test_options_put_call_ratio.py` | NEW: Unit tests |

### Testing Standards

[Source: docs/development/testing-strategy.md]

- Test file location: `backend/tests/test_options_put_call_ratio.py`
- Framework: pytest with pytest-asyncio
- Mock external APIs with `unittest.mock.AsyncMock`
- Test edge cases: API failure, empty response, extreme PCR values
- Coverage target: 90%+ for new code

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-30 | 0.1 | Initial draft with financial rationale | SM Agent |
| 2025-12-30 | 0.2 | Updated with ATM Dollar-Weighted methodology and DML integration | SM Agent |

---

## Dev Agent Record

### Agent Model Used
_To be filled during implementation_

### Debug Log References
_To be filled during implementation_

### Completion Notes List
_To be filled during implementation_

### File List
_To be filled during implementation_

---

## QA Results
_To be filled after QA review_
